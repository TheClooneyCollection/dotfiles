#+TITLE: Spacemacs Configuration

#+name: org-bable-execute does not work anymore?
#+BEGIN_SRC emacs-lisp
  ;(spacemacs/recompile-elpa)
#+END_SRC

* Key bindings
** =TAB= to toggle fold

   #+BEGIN_SRC emacs-lisp
   (define-key evil-normal-state-map (kbd "TAB") 'evil-toggle-fold)
   #+END_SRC

** =;= <-> =:= in every modes

   #+BEGIN_SRC emacs-lisp
     (global-set-key ":" (lambda () (interactive) (insert ";")))
     (global-set-key ";" (lambda () (interactive) (insert ":")))
   #+END_SRC

** =f= and =t=

   #+BEGIN_SRC emacs-lisp
     (define-key evil-normal-state-map "f" 'evil-avy-goto-char-2)
     (define-key evil-motion-state-map "f" 'evil-avy-goto-char-2)
     (define-key evil-visual-state-map "f" 'evil-avy-goto-char-in-line)
     (define-key evil-operator-state-map "f" 'evil-avy-goto-char-in-line)

     (defun evil-avy-find-char-to-in-line ()
       "Somehow this magically makes `evil-avy-goto-char' works as `evil-find-char-to'"
       (interactive)
       (evil-avy-goto-char-in-line))

     (define-key evil-visual-state-map "t" 'evil-avy-find-char-to-in-line)
     (define-key evil-operator-state-map "t" 'evil-avy-find-char-to-in-line)
   #+END_SRC

** =SPC [0-9]=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "0" 'delete-other-windows)
     (spacemacs/set-leader-keys "7" 'async-shell-command)
     (spacemacs/set-leader-keys "9" 'zen)
   #+END_SRC

** =SPC bs= to open project's scratch buffer

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "bs" 'td/switch-to-project-s-scratch-buffer)
   #+END_SRC

** =SPC fee= to edit configurations

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "fee" 'td/edit-configuration)
   #+END_SRC

** =SPC jj= and =SPC jk=

   #+BEGIN_SRC emacs-lisp

     (evil-define-avy-motion avy-goto-line-above line)
     (evil-define-avy-motion avy-goto-line-below line)

     (spacemacs/set-leader-keys
       "jj" 'evil-avy-goto-line-below
       "jk" 'evil-avy-goto-line-above)
   #+END_SRC
** =SPC mu= in slack-mode for selecting unread messages

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys-for-major-mode 'slack-mode
       "u" 'slack-select-unread-rooms)
   #+END_SRC

** =SPC oo= to edit =org-default-notes-file=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "oo" '(lambda ()
                                        (interactive)
                                        (find-file org-default-notes-file)))
   #+END_SRC

* Toggles

** auto-fill-mode

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-auto-fill-mode-on)
   #+END_SRC
** golden-ratio

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-golden-ratio-on)
   #+END_SRC
** centered-cursor

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-centered-point-globally-on)
   #+END_SRC

* Functions
** Edit Spacemacs's configuration

   #+BEGIN_SRC emacs-lisp
     (defun td/edit (filename)
       (find-file (concat dotspacemacs-directory filename)))

     (defun td/edit-configuration ()
       (interactive)
       (td/edit "configuration.org"))
   #+END_SRC

** Dedicate a window's purpose

   #+BEGIN_SRC emacs-lisp
     (defun td/dedicate-window-purpose ()
       (interactive)
       (purpose-set-window-purpose-dedicated-p nil t))
   #+END_SRC

* Behaviors

** Save buffers when losing focus

   #+BEGIN_SRC emacs-lisp
     (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
   #+END_SRC

* Packages

** alert

   #+BEGIN_SRC emacs-lisp
     (defun td/alert-notifier-notify (info)
       "Derived from the `alert-notifier-notify' function with added `-timeout' parameter"
       (if alert-notifier-command
           (let ((args
                  (list "-title"   (alert-encode-string (plist-get info :title))
                        "-appIcon" (or (plist-get info :icon) alert-notifier-default-icon)
                        "-message" (alert-encode-string (plist-get info :message))
                        "-timeout" (number-to-string alert-fade-time))))
             ;; Adding the `timeout' param will cause `terminal-notifier' to block the process.
             ;; Thus we are calling `async-start-process' here.
             (apply #'async-start-process "emamcs-alert" alert-notifier-command nil args)
         (alert-message-notify info))))

     (with-eval-after-load 'alert
       (alert-define-style 'td-notifier :title "Notify using terminal-notifier"
                           :notifier #'td/alert-notifier-notify))

     (setq alert-default-style 'td-notifier)
   #+END_SRC

** avy

   #+BEGIN_SRC emacs-lisp
     (setq avy-keys '(?a ?e ?i ?o ?u ?h ?t ?d ?s ?y))
   #+END_SRC

** company

*** Enable company globally

    #+BEGIN_SRC emacs-lisp
      (global-company-mode)
    #+END_SRC

*** Use Tab and Go

    #+BEGIN_SRC emacs-lisp
      (company-tng-configure-default)
    #+END_SRC

*** Enable company in text mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes text-mode)
    #+END_SRC

*** Enable company in swift mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes swift-mode)
    #+END_SRC

*** Fuzzy autocompletion

    #+BEGIN_SRC emacs-lisp
      (setq company-flx-limit 100)
      (company-flx-mode)
    #+END_SRC

** compile

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'compile
   #+END_SRC

   #+NAME: Remove spacemacs default coloring function
   #+BEGIN_SRC emacs-lisp
     (setq compilation-filter-hook nil)
   #+END_SRC

   #+NAME: Set alert fade time
   #+BEGIN_SRC emacs-lisp
     (setq alert-fade-time 10)
   #+END_SRC

   #+NAME: Add swift-fastlane error format to `compilation-error-regex-alist'
   #+BEGIN_SRC emacs-lisp
       (add-to-list 'compilation-error-regexp-alist-alist
                    '(swift-fastlane "^\\(\\/.*?\\.swift\\):\\([0-9]+\\)" 1 2))
       (add-to-list 'compilation-error-regexp-alist 'swift-fastlane)
   #+END_SRC

   #+NAME: Add alert for when compilations finish
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'compilation-finish-functions
                  (lambda (buffer string)
                    (alert string :title "Compilation finished")))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     )
   #+END_SRC

** helm

*** Notes

    - SPC / for search and replace, in many files!

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-mode-fuzzy-match t
            helm-completion-in-region-fuzzy-match t
            helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (setq helm-candidate-number-limit 20)
    #+END_SRC
*** ripgrep

    Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))
    #+END_SRC

** helm-ls-git

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "ff" 'helm-ls-git-ls)
   #+END_SRC

** magit

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "gg" 'magit-status)
   #+END_SRC

** org

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'org
   #+END_SRC

*** Load packages

    #+BEGIN_SRC emacs-lisp
      (require 'org-eww)
    #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq org-ellipsis "â¤µ")

      (setq org-M-RET-may-split-line nil)

      (setq org-directory "~/Dropbox/data/org/")

      (defun org-file-path (filename)
        (concat (file-name-as-directory org-directory) filename))

      (defun org-file-path-or-nil (filename)
        "Return the absolute address of an org file, given its relative name."
        (let ((file-path (org-file-path filename)))
          (if (file-exists-p file-path)
              file-path nil)))

      (setq org-default-notes-file (org-file-path "notes.org"))
      (setq org-agenda-files (cl-remove-if #'null (list org-directory
                                                        (org-file-path-or-nil "work/"))))
      (setq org-archive-location (format "%s::"
            (org-file-path "archive.org")))
    #+END_SRC

*** Add structure templates

    #+BEGIN_SRC emacs-lisp
      (dolist (item '(("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
                      ("ex" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
                      ("s" "#+BEGIN_SRC swift\n?\n#+END_SRC")
                      ("sh" "#+BEGIN_SRC sh :results output\n?\n#+END_SRC")
                      ("ss" "#+BEGIN_SRC ?\n\n#+END_SRC")
                      ("p" "#+BEGIN_SRC python :results output\n?\n#+END_SRC")))
        (add-to-list 'org-structure-template-alist item))
    #+END_SRC

*** Turn on =auto-fill-mode= for =org-mode=
    
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'spacemacs/toggle-auto-fill-mode-on)
    #+END_SRC

*** Babel

    #+BEGIN_SRC emacs-lisp
      (setq org-babel-python-command "/usr/local/bin/python3")
    #+END_SRC


**** Add =fish= shell to =org-babel-shell-names=

     #+BEGIN_SRC emacs-lisp
       (add-to-list 'org-babel-shell-names "fish")
       (org-babel-shell-initialize)
     #+END_SRC

**** Don't prompt me to confirm every time I want to evaluate a block.

     #+BEGIN_SRC emacs-lisp
       (setq org-confirm-babel-evaluate nil)
     #+END_SRC

**** =org-babel-execute:swift=

     #+BEGIN_SRC emacs-lisp
       (defun org-babel-execute:swift (body params)
         "Execute a block of Swift code with org-babel."
         (message "executing Swift source code block")
         (ob-swift--eval body))

       (defun ob-swift--eval (body)
         (with-temp-buffer
           (insert body)
           (shell-command-on-region (point-min) (point-max) "swift -" nil 't)
           (buffer-string)))

       (provide 'ob-swift)
     #+END_SRC

**** =org-babel-do-load-languages=
     Load languages

     #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (swift . t)
          (python . t)
          (ruby . t)

          (shell . t)
          ))
     #+END_SRC

*** THE END

    #+BEGIN_SRC emacs-lisp
    )
    #+END_SRC

** persp

   #+BEGIN_SRC emacs-lisp
     (setq persp-nil-name "@home")
   #+END_SRC

** projectile
*** =*scratch*= buffer per project

    #+BEGIN_SRC emacs-lisp
      (defun td/switch-to-project-s-scratch-buffer ()
        (interactive)
        (let ((buffer-name (format "*scratch: %S*" (projectile-project-name))))
          (if-let (buffer (get-buffer buffer-name)) ; buffer exists
              (switch-to-buffer buffer)
            (progn                            ; buffer does not exist
              (switch-to-buffer (get-buffer-create buffer-name))
              (org-mode)
              (insert (format "#+TITLE %S\n\n" (projectile-project-name)))))))
    #+END_SRC
*** =zen=

    #+BEGIN_SRC emacs-lisp
      (defun zen ()
        (interactive)
        (progn
          (td/switch-to-project-s-scratch-buffer)
          (delete-other-windows)
          (td/dedicate-window-purpose)))
    #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq projectile-enable-caching t)
      (setq projectile-switch-project-action 'zen)

      (setq projectile-tags-backend 'etag-select)
    #+END_SRC

*** Discover projects

    #+BEGIN_SRC emacs-lisp
      (projectile-discover-projects-in-directory "~/work")
      (projectile-discover-projects-in-directory "~/proj")
    #+END_SRC

** purpose

   #+BEGIN_SRC emacs-lisp
     (setq purpose-user-mode-purposes '((magit-mode . util)
                                        (slack-mode . util)))
     (setq purpose-user-regexp-purposes '(
                                          ;("^*scratch: [\"a-zA-Z0-9]" . edit)
                                          ))

     (purpose-compile-user-configuration)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'magit-mode-setup-hook 'td/dedicate-window-purpose)
   #+END_SRC
** slack

   #+BEGIN_SRC emacs-lisp
     (setq slack-prefer-current-team t
           slack-buffer-function #'switch-to-buffer)
   #+END_SRC

*** Set up slack for =work=

  #+BEGIN_SRC emacs-lisp
    (spacemacs|use-package-add-hook slack
      :post-config
      (progn
        ;; Turn off centered-point-mode in slack mode
        (add-hook 'slack-mode-hook '(lambda () (centered-cursor-mode -1)))

        ;; Workaround for channels containing unsupported message format
        (defun sbw/slack-mode--catch-message-to-string-error (orig-fun &rest args)
          (condition-case nil
              (apply orig-fun args)
            (error "<error parsing message>\n")))

        (advice-add 'slack-message-to-string :around #'sbw/slack-mode--catch-message-to-string-error)

        (let* ((auth-info (car (auth-source-search :max 1
                                                   :user "work"
                                                   :host "slack")))

               (team-name (plist-get auth-info :team-name))
               (client-id (plist-get auth-info :client-id))
               (client-secret (plist-get auth-info :client-secret))
               (token (plist-get auth-info :token)))

          (slack-register-team
           :default t
           :name team-name
           :client-id client-id
           :client-secret client-secret
           :token token))

        (defun td/slack-update-all ()
          (interactive)
          (slack-im-list-update)
          (slack-group-list-update)
          (slack-channel-list-update))
        ))
  #+END_SRC

** yasnippet

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'yasnippet
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'text-mode-hook 'yas-minor-mode)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq yas-snippet-dirs '("~/.spacemacs.d/snippets"))
     (yas-reload-all)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; Bind `SPC' to `yas-expand' when snippet expansion available (it
     ;; will still call `self-insert-command' otherwise).
     (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)
     (define-key yas-minor-mode-map (kbd "C-c C-c") yas-maybe-expand)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     )
   #+END_SRC

