#+TITLE: Spacemacs Configuration

#+name: org-bable-execute does not work anymore?
#+BEGIN_SRC emacs-lisp
  ;(spacemacs/recompile-elpa)
#+END_SRC

* Key bindings
** =TAB= to toggle fold

   #+BEGIN_SRC emacs-lisp
   (define-key evil-normal-state-map (kbd "TAB") 'evil-toggle-fold)
   #+END_SRC

** =;= <-> =:= in every modes

   #+BEGIN_SRC emacs-lisp
     (global-set-key ":" (lambda () (interactive) (insert ";")))
     (global-set-key ";" (lambda () (interactive) (insert ":")))
   #+END_SRC

** =f= and =t=

   #+BEGIN_SRC emacs-lisp
     (define-key evil-normal-state-map "f" 'evil-avy-goto-char-2)
     (define-key evil-motion-state-map "f" 'evil-avy-goto-char-2)
     (define-key evil-visual-state-map "f" 'evil-avy-goto-char-in-line)
     (define-key evil-operator-state-map "f" 'evil-avy-goto-char-in-line)

     (defun evil-avy-find-char-to-in-line ()
       "Somehow this magically makes `evil-avy-goto-char' works as `evil-find-char-to'"
       (interactive)
       (evil-avy-goto-char-in-line))

     (define-key evil-visual-state-map "t" 'evil-avy-find-char-to-in-line)
     (define-key evil-operator-state-map "t" 'evil-avy-find-char-to-in-line)
   #+END_SRC

** =SPC [0-9]=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "0" 'delete-other-windows)
     (spacemacs/set-leader-keys "7" 'async-shell-command)
     (spacemacs/set-leader-keys "9" 'zen)
   #+END_SRC

** =SPC bs= to open project's scratch buffer

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "bs" 'td/switch-to-project-s-scratch-buffer)
   #+END_SRC

** =SPC fee= to edit configurations

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "fee" 'td/edit-configuration)
   #+END_SRC

** =SPC jj= and =SPC jk=

   #+BEGIN_SRC emacs-lisp

     (evil-define-avy-motion avy-goto-line-above line)
     (evil-define-avy-motion avy-goto-line-below line)

     (spacemacs/set-leader-keys
       "jj" 'evil-avy-goto-line-below
       "jk" 'evil-avy-goto-line-above)
   #+END_SRC
** =SPC mu= in slack-mode for selecting unread messages

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys-for-major-mode 'slack-mode
       "u" 'slack-select-unread-rooms)
   #+END_SRC

** =SPC oo= to edit =org-default-notes-file=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "oo" '(lambda ()
                                        (interactive)
                                        (find-file org-default-notes-file)))
   #+END_SRC

* Toggles

** auto-fill-mode

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-auto-fill-mode-on)
   #+END_SRC
** golden-ratio

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-golden-ratio-on)
   #+END_SRC
** centered-cursor

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-centered-point-globally-on)
   #+END_SRC

* Functions
** Edit Spacemacs's configuration

   #+BEGIN_SRC emacs-lisp
     (defun td/edit (filename)
       (find-file (concat dotspacemacs-directory filename)))

     (defun td/edit-configuration ()
       (interactive)
       (td/edit "configuration.org"))
   #+END_SRC

** Dedicate a window's purpose

   #+BEGIN_SRC emacs-lisp
     (defun td/dedicate-window-purpose ()
       (interactive)
       (purpose-set-window-purpose-dedicated-p nil t))
   #+END_SRC

* Behaviors

** Save buffers when losing focus

   #+BEGIN_SRC emacs-lisp
     (add-hook 'focus-out-hook (lambda () (save-some-buffers t)))
   #+END_SRC

* Packages

** alert

   #+BEGIN_SRC emacs-lisp
     (defun td/alert-notifier-notify (info)
       "Derived from the `alert-notifier-notify' function with added `-timeout' parameter"
       (if alert-notifier-command
           (let ((args
                  (list "-title"   (alert-encode-string (plist-get info :title))
                        "-appIcon" (or (plist-get info :icon) alert-notifier-default-icon)
                        "-message" (alert-encode-string (plist-get info :message))
                        "-timeout" (number-to-string alert-fade-time))))
             ;; Adding the `timeout' param will cause `terminal-notifier' to block the process.
             ;; Thus we are calling `async-start-process' here.
             (apply #'async-start-process "emamcs-alert" alert-notifier-command nil args)
         (alert-message-notify info))))

     (with-eval-after-load 'alert
       (alert-define-style 'td-notifier :title "Notify using terminal-notifier"
                           :notifier #'td/alert-notifier-notify))

     (setq alert-default-style 'td-notifier)
   #+END_SRC

** avy

   #+BEGIN_SRC emacs-lisp
     (setq avy-keys '(?a ?e ?i ?o ?u ?h ?t ?d ?s ?y))
   #+END_SRC

** company

*** Enable company globally

    #+BEGIN_SRC emacs-lisp
      (global-company-mode)
    #+END_SRC

*** Use Tab and Go

    #+BEGIN_SRC emacs-lisp
      (company-tng-configure-default)
    #+END_SRC

*** Enable company in text mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes text-mode)
    #+END_SRC

*** Enable company in swift mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes swift-mode)
    #+END_SRC

*** Fuzzy autocompletion

    #+BEGIN_SRC emacs-lisp
      (setq company-flx-limit 100)
      (company-flx-mode)
    #+END_SRC

** compile

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'compile
   #+END_SRC

   #+NAME: Remove spacemacs default coloring function
   #+BEGIN_SRC emacs-lisp
     (setq compilation-filter-hook nil)
   #+END_SRC

   #+NAME: Set alert fade time
   #+BEGIN_SRC emacs-lisp
     (setq alert-fade-time 10)
   #+END_SRC

   #+NAME: Add swift-fastlane error format to `compilation-error-regex-alist'
   #+BEGIN_SRC emacs-lisp
       (add-to-list 'compilation-error-regexp-alist-alist
                    '(swift-fastlane "^\\(\\/.*?\\.swift\\):\\([0-9]+\\)" 1 2))
       (add-to-list 'compilation-error-regexp-alist 'swift-fastlane)
   #+END_SRC

   #+NAME: Add alert for when compilations finish
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'compilation-finish-functions
                  (lambda (buffer string)
                    (alert string :title "Compilation finished")))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     )
   #+END_SRC

** gud

*** gud-lldb

    #+BEGIN_SRC emacs-lisp
      ;;; gud-lldb.el --- Grand Unified Debugger mode for running LLDB

      ;; Copyright (C) 1992-1996, 1998, 2000-2014 Free Software Foundation,
      ;; Inc.

      ;; Author: Eric S. Raymond <esr@snark.thyrsus.com>
      ;; Maintainer: emacs-devel@gnu.org
      ;; Keywords: unix, tools, osx

      ;; This file is part of GNU Emacs.

      ;; GNU Emacs is free software: you can redistribute it and/or modify
      ;; it under the terms of the GNU General Public License as published by
      ;; the Free Software Foundation, either version 3 of the License, or
      ;; (at your option) any later version.

      ;; GNU Emacs is distributed in the hope that it will be useful,
      ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
      ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      ;; GNU General Public License for more details.

      ;; You should have received a copy of the GNU General Public License
      ;; along with GNU Emacs.  If not, see <http://www.gnu.org/licenses/>.

      ;;; Commentary:

      ;; This file contains an extract of the gud.el version from
      ;; `http://opensource.apple.com/source/lldb/lldb-69/utils/emacs/gud.el'

      ;;; Code:

      (require 'gud)


      ;; History of argument lists passed to lldb.
      (defvar gud-lldb-history nil)

      ;; Keeps track of breakpoint created.  In the following case, the id is "1".
      ;; It is used to implement temporary breakpoint.
      ;; (lldb) b main.c:39
      ;; breakpoint set --file 'main.c' --line 39
      ;; Breakpoint created: 1: file ='main.c', line = 39, locations = 1
      (defvar gud-breakpoint-id nil)

      (defun lldb-extract-breakpoint-id (string)
        ;; Search for "Breakpoint created: \\([^:\n]*\\):" pattern.
        ;(message "gud-marker-acc string is: |%s|" string)
        (if (string-match "Breakpoint created: \\([^:\n]*\\):" string)
            (progn
              (setq gud-breakpoint-id (match-string 1 string))
              (message "breakpoint id: %s" gud-breakpoint-id)))
      )

      (defun gud-lldb-marker-filter (string)
        (setq gud-marker-acc
          (if gud-marker-acc (concat gud-marker-acc string) string))
        (lldb-extract-breakpoint-id gud-marker-acc)
        (let (start)
          ;; Process all complete markers in this chunk
          (while (or
                  ;; (lldb) r
                  ;; Process 15408 launched: '/Volumes/data/lldb/svn/trunk/test/conditional_break/a.out' (x86_64)
                  ;; (lldb) Process 15408 stopped
                  ;; * thread #1: tid = 0x2e03, 0x0000000100000de8 a.out`c + 7 at main.c:39, stop reason = breakpoint 1.1, queue = com.apple.main-thread
                  (string-match " at \\([^:\n]*\\):\\([0-9]*\\), stop reason = .*\n"
                                gud-marker-acc start)
                  ;; (lldb) frame select -r 1
                  ;; frame #1: 0x0000000100000e09 a.out`main + 25 at main.c:44
                  (string-match "^[ ]*frame.* at \\([^:\n]*\\):\\([0-9]*\\)\n"
                                 gud-marker-acc start))
            ;(message "gud-marker-acc matches our pattern....")
            (setq gud-last-frame
                  (cons (match-string 1 gud-marker-acc)
                        (string-to-number (match-string 2 gud-marker-acc)))
                  start (match-end 0)))

          ;; Search for the last incomplete line in this chunk
          (while (string-match "\n" gud-marker-acc start)
            (setq start (match-end 0)))

          ;; If we have an incomplete line, store it in gud-marker-acc.
          (setq gud-marker-acc (substring gud-marker-acc (or start 0))))
        string)

      ;; Keeps track of whether the Python lldb_oneshot_break function definition has
      ;; been exec'ed.
      (defvar lldb-oneshot-break-defined nil)

      ;;;###autoload
      (defun lldb (command-line)
        "Run lldb on program FILE in buffer *gud-FILE*.
      The directory containing FILE becomes the initial working directory
      and source-file directory for your debugger."
        (interactive (list (gud-query-cmdline 'lldb)))

        (gud-common-init command-line nil 'gud-lldb-marker-filter)
        (set (make-local-variable 'gud-minor-mode) 'lldb)
        (setq lldb-oneshot-break-defined nil)

        ;; Make lldb dump fullpath instead of basename for a file.
        ;; See also gud-lldb-marker-filter where gud-last-frame is grokked from lldb output.
        (progn
          (gud-call "settings set frame-format frame #${frame.index}: ${frame.pc}{ ${module.file.basename}{`${function.name}${function.pc-offset}}}{ at ${line.file.fullpath}:${line.number}}\\n")
          (sit-for 1)
          (gud-call "settings set thread-format thread #${thread.index}: tid = ${thread.id}{, ${frame.pc}}{ ${module.file.basename}{`${function.name}${function.pc-offset}}}{ at ${line.file.fullpath}:${line.number}}{, stop reason = ${thread.stop-reason}}\\n")
          (sit-for 1))

        (gud-def gud-listb  "breakpoint list"
                            "l"    "List all breakpoints.")
        (gud-def gud-bt     "thread backtrace"
                            "b"    "Show stack for the current thread.")
        (gud-def gud-bt-all "thread backtrace all"
                            "B"    "Show stacks for all the threads.")

        (gud-def gud-break  "breakpoint set -f %f -l %l"
                            "\C-b" "Set breakpoint at current line.")
        (gud-def gud-tbreak
             (progn (gud-call "breakpoint set -f %f -l %l")
                        (sit-for 1)
                        (if (not lldb-oneshot-break-defined)
                            (progn
                              ;; The "\\n"'s are required to escape the newline chars
                              ;; passed to the lldb process.
                              (gud-call (concat "script exec \"def lldb_oneshot_break(frame, bp_loc):\\n"
                                                              "    target=frame.GetThread().GetProcess().GetTarget()\\n"
                                                              "    bp=bp_loc.GetBreakpoint()\\n"
                                                              "    print 'Deleting oneshot breakpoint:', bp\\n"
                                                              "    target.BreakpointDelete(bp.GetID())\""))
                              (sit-for 1)
                              ;; Set the flag since Python knows about the function def now.
                              (setq lldb-oneshot-break-defined t)))
                        (gud-call "breakpoint command add -p %b -o 'lldb_oneshot_break(frame, bp_loc)'"))
                        "\C-t" "Set temporary breakpoint at current line.")
        (gud-def gud-remove "breakpoint clear -f %f -l %l"
                            "\C-d" "Remove breakpoint at current line")
        (gud-def gud-step   "thread step-in"
                            "\C-s" "Step one source line with display.")
        (gud-def gud-stepi  "thread step-inst"
                            "\C-i" "Step one instruction with display.")
        (gud-def gud-next   "thread step-over"
                            "\C-n" "Step one line (skip functions).")
        (gud-def gud-nexti  "thread step-inst-over"
                            nil    "Step one instruction (skip functions).")
        (gud-def gud-cont   "process continue"
                            "\C-r" "Continue with display.")
        (gud-def gud-finish "thread step-out"
                            "\C-f" "Finish executing current function.")
        (gud-def gud-up
                 (progn (gud-call "frame select -r 1")
                        (sit-for 1))
                            "<"    "Up 1 stack frame.")
        (gud-def gud-down
                 (progn (gud-call "frame select -r -1")
                        (sit-for 1))
                            ">"    "Down 1 stack frame.")
        (gud-def gud-print  "expression -- %e"
                            "\C-p" "Evaluate C expression at point.")
        (gud-def gud-pstar  "expression -- *%e"
                            nil    "Evaluate C dereferenced pointer expression at point.")
        (gud-def gud-run    "run"
                            "r"    "Run the program.")
        (gud-def gud-stop-subjob    "process kill"
                            "s"    "Stop the program.")

        (setq comint-prompt-regexp  "\\(^\\|\n\\)\\*")
        (setq paragraph-start comint-prompt-regexp)
        (run-hooks 'lldb-mode-hook)
        )

      ;; ;; tooltip
      ;; (defun gud-lldb-tooltip-print-command (expr)
      ;;   "Return a suitable command to print the expression EXPR."
      ;;   (pcase gud-minor-mode
      ;;     ;; '-o' to print the objc object description if available
      ;;     (`lldb (concat "expression -o -- " expr))
      ;;     (`gdbmi (concat "-data-evaluate-expression \"" expr "\""))
      ;;     (`guiler expr)
      ;;     (`dbx (concat "print " expr))
      ;;     ((or `xdb `pdb) (concat "p " expr))
      ;;     (`sdb (concat expr "/"))))

      ;; (advice-add 'gud-tooltip-print-command :override #'gud-lldb-tooltip-print-command)

      ;; menu
      (setcdr (nth 2 (nth 7 (assoc 'nexti gud-menu-map))) '((lldb gdbmi gdb dbx)))
      (setcdr (nth 2 (nth 7 (assoc 'stepi gud-menu-map))) '((lldb gdbmi gdb dbx)))
      (setcdr (nth 2 (nth 7 (assoc 'finish gud-menu-map))) '((lldb gdbmi gdb guiler xdb jdb pdb)))
      (setcdr (nth 2 (nth 7 (assoc 'print* gud-menu-map))) '((lldb gdbmi gdb jdb)))
      (setcdr (nth 2 (nth 7 (assoc 'down gud-menu-map))) '((lldb gdbmi gdb guiler dbx xdb jdb pdb)))
      (setcdr (nth 2 (nth 7 (assoc 'up gud-menu-map))) '((lldb gdbmi gdb guiler dbx xdb jdb pdb)))
      (setcdr (nth 2 (nth 7 (assoc 'tbreak gud-menu-map))) '((lldb gdbmi gdb sdb xdb)))
      (setcdr (nth 2 (nth 7 (assoc 'run gud-menu-map))) '((lldb gdbmi gdb dbx jdb)))
      ;; (setcdr (nth 2 (nth 7 (assoc 'tooltips gud-menu-map))) '((lldb gdbmi guiler dbx sdb xdb pdb)))


      (provide 'gud-lldb)

      ;;; gud-lldb.el ends here

    #+END_SRC
** helm

*** Notes

    - SPC / for search and replace, in many files!

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-mode-fuzzy-match t
            helm-completion-in-region-fuzzy-match t
            helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (setq helm-candidate-number-limit 20)
    #+END_SRC
*** ripgrep

    Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))
    #+END_SRC

** helm-ls-git

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "ff" 'helm-ls-git-ls)
   #+END_SRC

** magit

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "gg" 'magit-status)
   #+END_SRC

** magithub

   #+BEGIN_SRC emacs-lisp
     (use-package magithub
       :after magit
       :ensure t
       :init
       (setq magithub-dir (concat spacemacs-cache-directory "magithub/"))
       :config
       (progn
         (magithub-feature-autoinject t)
         (define-key magit-status-mode-map "@" #'magithub-dispatch-popup)))
   #+END_SRC

** org

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'org
   #+END_SRC

*** Load packages

    #+BEGIN_SRC emacs-lisp
      (require 'org-eww)
    #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq org-ellipsis "â¤µ")

      (setq org-M-RET-may-split-line nil)

      (setq org-directory "~/Dropbox/data/org/")

      (defun org-file-path (filename)
        (concat (file-name-as-directory org-directory) filename))

      (defun org-file-path-or-nil (filename)
        "Return the absolute address of an org file, given its relative name."
        (let ((file-path (org-file-path filename)))
          (if (file-exists-p file-path)
              file-path nil)))

      (setq org-default-notes-file (org-file-path "notes.org"))
      (setq org-agenda-files (cl-remove-if #'null (list org-directory
                                                        (org-file-path-or-nil "work/"))))
      (setq org-archive-location (format "%s::"
            (org-file-path "archive.org")))
    #+END_SRC

*** Add structure templates

    #+BEGIN_SRC emacs-lisp
      (dolist (item '(("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
                      ("ex" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
                      ("s" "#+BEGIN_SRC swift\n?\n#+END_SRC")
                      ("sh" "#+BEGIN_SRC sh :results output\n?\n#+END_SRC")
                      ("ss" "#+BEGIN_SRC ?\n\n#+END_SRC")
                      ("p" "#+BEGIN_SRC python :results output\n?\n#+END_SRC")))
        (add-to-list 'org-structure-template-alist item))
    #+END_SRC

*** Turn on =auto-fill-mode= for =org-mode=
    
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'spacemacs/toggle-auto-fill-mode-on)
    #+END_SRC

*** Babel

    #+BEGIN_SRC emacs-lisp
      (setq org-babel-python-command "/usr/local/bin/python3")
    #+END_SRC

**** Don't prompt me to confirm every time I want to evaluate a block.

     #+BEGIN_SRC emacs-lisp
       (setq org-confirm-babel-evaluate nil)
     #+END_SRC

**** =org-babel-execute:swift=

     #+BEGIN_SRC emacs-lisp
       (defun org-babel-execute:swift (body params)
         "Execute a block of Swift code with org-babel."
         (message "executing Swift source code block")
         (ob-swift--eval body))

       (defun ob-swift--eval (body)
         (with-temp-buffer
           (insert body)
           (shell-command-on-region (point-min) (point-max) "swift -" nil 't)
           (buffer-string)))

       (provide 'ob-swift)
     #+END_SRC

**** =org-babel-do-load-languages=
     Load languages

     #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (swift . t)
          (python . t)
          (ruby . t)

          (shell . t)
          ))
     #+END_SRC

*** THE END

    #+BEGIN_SRC emacs-lisp
    )
    #+END_SRC

** persp

   #+BEGIN_SRC emacs-lisp
     (setq persp-nil-name "@home")
   #+END_SRC

** projectile
*** =*scratch*= buffer per project

    #+BEGIN_SRC emacs-lisp
      (defun td/switch-to-project-s-scratch-buffer ()
        (interactive)
        (let ((buffer-name (format "*scratch: %S*" (projectile-project-name))))
          (if-let (buffer (get-buffer buffer-name)) ; buffer exists
              (switch-to-buffer buffer)
            (progn                            ; buffer does not exist
              (switch-to-buffer (get-buffer-create buffer-name))
              (org-mode)
              (insert (format "#+TITLE %S\n\n" (projectile-project-name)))))))
    #+END_SRC
*** =zen=

    #+BEGIN_SRC emacs-lisp
      (defun zen ()
        (interactive)
        (progn
          (delete-other-windows)
          (td/switch-to-project-s-scratch-buffer)
          (td/dedicate-window-purpose)))
    #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq projectile-enable-caching t)
      (setq projectile-switch-project-action 'zen)

      (setq projectile-tags-backend 'etag-select)
    #+END_SRC

*** Discover projects

    #+BEGIN_SRC emacs-lisp
      (projectile-discover-projects-in-directory "~/work")
      (projectile-discover-projects-in-directory "~/proj")
    #+END_SRC

** purpose

   #+BEGIN_SRC emacs-lisp
     (setq purpose-user-mode-purposes '((magit-mode . util)
                                        (slack-mode . util)))
     (setq purpose-user-regexp-purposes '(
                                          ;("^*scratch: [\"a-zA-Z0-9]" . edit)
                                          ))

     (purpose-compile-user-configuration)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'magit-mode-setup-hook 'td/dedicate-window-purpose)
   #+END_SRC
** slack

   #+BEGIN_SRC emacs-lisp
     (setq slack-prefer-current-team t
           slack-buffer-function #'switch-to-buffer)
   #+END_SRC

*** Set up slack for =work=

  #+BEGIN_SRC emacs-lisp
    (spacemacs|use-package-add-hook slack
      :post-config
      (progn
        ;; Turn off centered-point-mode in slack mode
        (add-hook 'slack-mode-hook '(lambda () (centered-cursor-mode -1)))

        ;; Workaround for channels containing unsupported message format
        (defun sbw/slack-mode--catch-message-to-string-error (orig-fun &rest args)
          (condition-case nil
              (apply orig-fun args)
            (error "<error parsing message>\n")))

        (advice-add 'slack-message-to-string :around #'sbw/slack-mode--catch-message-to-string-error)

        (let* ((auth-info (car (auth-source-search :max 1
                                                   :user "work"
                                                   :host "slack")))

               (team-name (plist-get auth-info :team-name))
               (client-id (plist-get auth-info :client-id))
               (client-secret (plist-get auth-info :client-secret))
               (token (plist-get auth-info :token)))

          (slack-register-team
           :default t
           :name team-name
           :client-id client-id
           :client-secret client-secret
           :token token))

        (defun td/slack-update-all ()
          (interactive)
          (slack-im-list-update)
          (slack-group-list-update)
          (slack-channel-list-update))
        ))
  #+END_SRC

** yasnippet

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'yasnippet
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (setq yas-snippet-dirs '("~/.spacemacs.d/snippets"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     ;; Bind `SPC' to `yas-expand' when snippet expansion available (it
     ;; will still call `self-insert-command' otherwise).
     (define-key yas-minor-mode-map (kbd "SPC") yas-maybe-expand)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     )
   #+END_SRC

