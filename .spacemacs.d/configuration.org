#+TITLE: Spacemacs Configuration

* Toggles

** auto-fill-mode

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-auto-fill-mode-on)
   #+END_SRC
** golden-ratio

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-golden-ratio-on)
   #+END_SRC
** centered-cursor

   #+BEGIN_SRC emacs-lisp
     (spacemacs/toggle-centered-point-on)
   #+END_SRC

* Functions
** Edit Spacemacs's configuration
   #+BEGIN_SRC emacs-lisp
     (defun td/edit (filename)
       (find-file (concat dotspacemacs-directory filename)))

     (defun td/edit-configuration ()
       (interactive)
       ;(td/edit "configuration.emacs.org")
       (td/edit "configuration.org"))
   #+END_SRC
** Dedicate a window's purpose

   #+BEGIN_SRC emacs-lisp
     (defun td/dedicate-window-purpose ()
       (interactive)
       (purpose-set-window-purpose-dedicated-p nil t))
   #+END_SRC

* Packages

** alert

   #+BEGIN_SRC emacs-lisp
     (setq alert-default-style 'notifier)
   #+END_SRC

** avy

   #+BEGIN_SRC emacs-lisp
     (setq avy-keys '(?a ?e ?i ?o ?u ?h ?t ?d ?s))
   #+END_SRC

** company

*** Enable company globally

    #+BEGIN_SRC emacs-lisp
      (global-company-mode)
    #+END_SRC

*** Enable company in text mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes text-mode)
    #+END_SRC

*** Enable company in swift mode too

    #+BEGIN_SRC emacs-lisp
      (spacemacs|add-company-backends
        :backends company-capf
        :modes swift-mode)
    #+END_SRC

*** Fuzzy autocompletion

    #+BEGIN_SRC emacs-lisp
      (setq company-flx-limit 100)
      (company-flx-mode)
    #+END_SRC

*** Complete with tab

**** Source

     From https://github.com/company-mode/company-mode/issues/526#issuecomment-324433126

     Also, a PR in company-mode's repo: https://github.com/company-mode/company-mode/pull/706
    
     #+BEGIN_SRC emacs-lisp
       ;;; company-insert-selected.el
       ;;
       ;; Similar to the way neocomplete package from Vim deals with autocompletion
       ;;

       (defvar-local company-insert-selected--overlay nil)
       (defvar company-insert-selected--complete-func 'company-complete-selection)

       (defun company--company-command-p (keys)
         "Checks if the keys are part of company's overriding keymap"
         (or (equal [company-dummy-event] keys)
             (lookup-key company-my-keymap keys)))

       (defun company-insert-selected-frontend (command)
         "When the user changes the selection at least once, this
       frontend will display the candidate in the buffer as if it's
       already there and any key outside of `company-active-map' will
       confirm the selection and finish the completion."
         (cl-case command
           (show
            (setq company-insert-selected--overlay (make-overlay (point) (point)))
            (overlay-put company-insert-selected--overlay 'priority 2)
            (advice-add 'company-fill-propertize :filter-args 'company-insert-selected//adjust-tooltip-highlight))
           (update
            (let ((ov company-insert-selected--overlay)
                  (selected (nth company-selection company-candidates))
                  (prefix (length company-prefix)))
              (move-overlay ov (- (point) prefix) (point))
              (overlay-put ov 'display (and company-selection-changed selected))))
           (hide
            (advice-remove 'company-fill-propertize 'company-insert-selected//adjust-tooltip-highlight)
            (when company-insert-selected--overlay
              (delete-overlay company-insert-selected--overlay)))
           (pre-command
            (when (and company-selection-changed
                       (not (company--company-command-p (this-command-keys))))
              (funcall company-insert-selected--complete-func)))))

       (defun company-insert-selected//adjust-tooltip-highlight (args)
         "Don't allow the tooltip to highlight the current selection if
       it wasn't made explicitly (i.e. `company-selection-changed' is
       true)"
         (unless company-selection-changed
           ;; The 4th arg of `company-fill-propertize' is selected
           (setf (nth 3 args) nil))
         args)

       (defun company-select-first-then-next (&optional arg)
         (interactive "p")
         (if company-selection-changed
             (company-select-next arg)
           (company-set-selection (1- (or arg 1)) 'force-update)))

       (defun company-select-previous-then-none (&optional arg)
         (interactive "p")
         (if (or (not company-selection-changed)
                 (> company-selection (1- (or arg 1))))
             (company-select-previous arg)
           (company-set-selection 0)
           (setq company-selection-changed nil)
           (company-call-frontends 'update)))

       ;; Integrate with evil if it's present
       (eval-after-load 'evil
         '(progn
            (defun company-insert-selected//complete-with-repeat ()
              "Call `company-complete-selection' but also invoke evil's
       pre and post command hooks to monitor for the changes that the
       completion function will do.
       Because the completion function is called from a pre-command hook
       it won't be caught by evil's repeat monitoring, as evil itself
       relies on pre-command and post-command hooks to install it's own
       monitoring hooks."
              (let ((this-command 'company-complete-selection))
                (evil-repeat-pre-hook)
                (company-complete-selection)
                (evil-repeat-post-hook)))
            (setq company-insert-selected--complete-func 'company-insert-selected//complete-with-repeat)

            ;; See evil/evil-integration.el, same thing is done for other company functions
            (evil-declare-ignore-repeat 'company-select-first-then-next)
            (evil-declare-ignore-repeat 'company-select-previous-then-none)))

       (provide 'company-insert-selected)
     #+END_SRC

**** Configuration

     #+BEGIN_SRC emacs-lisp
       (use-package company-insert-selected
         :ensure nil
         :pin manual
         :after company
         :bind (:map company-active-map
                     ("TAB" . company-select-first-then-next)
                     ("<tab>" . company-select-first-then-next)
                     ("<S-tab>" . company-select-previous-then-none)
                     ("<backtab>" . company-select-previous-then-none))
         :config
         (unbind-key "<return>" company-active-map)
         (unbind-key "RET" company-active-map)

         (setq company-frontends '(company-insert-selected-frontend
                                   company-pseudo-tooltip-frontend
                                   company-echo-metadata-frontend))
         (setq company-selection-wrap-around t))
     #+END_SRC

** helm

*** Notes

    - SPC / for search and replace, in many files!

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-mode-fuzzy-match t
            helm-completion-in-region-fuzzy-match t
            helm-M-x-fuzzy-match t
            helm-buffers-fuzzy-matching t)
    #+END_SRC

    #+BEGIN_SRC emacs-lisp
      (setq helm-candidate-number-limit 20)
    #+END_SRC
*** ripgrep

    Settings

    #+BEGIN_SRC emacs-lisp
      (setq helm-grep-ag-command "rg --color=always --colors 'match:fg:black' --colors 'match:bg:yellow' --smart-case --no-heading --line-number %s %s %s")
      (setq helm-grep-ag-pipe-cmd-switches '("--colors 'match:fg:black'" "--colors 'match:bg:yellow'"))
    #+END_SRC

** helm-ls-git

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "ff" 'helm-ls-git-ls)
   #+END_SRC

** magit

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "gg" 'magit-status)
   #+END_SRC

** org

   #+BEGIN_SRC emacs-lisp
     (with-eval-after-load 'org
   #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq org-ellipsis "⤵")

      (setq org-M-RET-may-split-line nil)

      (setq org-directory "~/Dropbox/data/org/")

      (defun org-file-path (filename)
        (concat (file-name-as-directory org-directory) filename))

      (defun org-file-path-or-nil (filename)
        "Return the absolute address of an org file, given its relative name."
        (let ((file-path (org-file-path filename)))
          (if (file-exists-p file-path)
              file-path nil)))

      (setq org-default-notes-file (org-file-path "notes.org"))
      (setq org-agenda-files (cl-remove-if #'null (list org-directory
                                                        (org-file-path-or-nil "work/"))))
      (setq org-archive-location (format "%s::"
            (org-file-path "archive.org")))
    #+END_SRC

*** Add structure templates

    #+BEGIN_SRC emacs-lisp
      (dolist (item '(("e" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
                      ("s" "#+BEGIN_SRC swift\n?\n#+END_SRC")
                      ("sh" "#+BEGIN_SRC sh :results raw\n?\n#+END_SRC")
                      ("ss" "#+BEGIN_SRC ?\n\n#+END_SRC")
                      ("p" "#+BEGIN_SRC python :results output\n?\n#+END_SRC")))
        (add-to-list 'org-structure-template-alist item))
    #+END_SRC

*** Turn on =auto-fill-mode= for =org-mode=
    
    #+BEGIN_SRC emacs-lisp
      (add-hook 'org-mode-hook 'spacemacs/toggle-auto-fill-mode-on)
    #+END_SRC

*** Babel

    #+BEGIN_SRC emacs-lisp
      (setq org-babel-python-command "/usr/local/bin/python3")
    #+END_SRC

**** Don't prompt me to confirm every time I want to evaluate a block.

     #+BEGIN_SRC emacs-lisp
       (setq org-confirm-babel-evaluate nil)
     #+END_SRC

**** =org-babel-execute:swift=

     #+BEGIN_SRC emacs-lisp
       (defun org-babel-execute:swift (body params)
         "Execute a block of Swift code with org-babel."
         (message "executing Swift source code block")
         (ob-swift--eval body))

       (defun ob-swift--eval (body)
         (with-temp-buffer
           (insert body)
           (shell-command-on-region (point-min) (point-max) "swift -" nil 't)
           (buffer-string)))

       (provide 'ob-swift)
     #+END_SRC

**** =org-babel-do-load-languages=
     Load languages

     #+BEGIN_SRC emacs-lisp
       (org-babel-do-load-languages
        'org-babel-load-languages
        '(
          (swift . t)
          (python . t)
          (ruby . t)

          (shell . t)
          ))
     #+END_SRC

** projectile
*** =*scratch*= buffer per project

    #+BEGIN_SRC emacs-lisp
      (defun switch-to-project-s-scratch-buffer ()
        (interactive)
        (let ((buffer-name (format "*scratch: %S*" (projectile-project-name))))
          (if-let (buffer (get-buffer buffer-name)) ; buffer exists
              (switch-to-buffer buffer)
            (progn                            ; buffer does not exist
              (switch-to-buffer (get-buffer-create buffer-name))
              (org-mode)
              (insert (format "#+TITLE %S\n\n" (projectile-project-name)))))))
    #+END_SRC
*** =zen=

    #+BEGIN_SRC emacs-lisp
      (defun zen ()
        (interactive)
        (progn
          (delete-other-windows)
          (switch-to-project-s-scratch-buffer)
          (td/dedicate-window-purpose)))
    #+END_SRC

*** Settings

    #+BEGIN_SRC emacs-lisp
      (setq projectile-enable-caching t)
      (setq projectile-switch-project-action 'zen)
    #+END_SRC

*** Discover projects

    #+BEGIN_SRC emacs-lisp
      (projectile-discover-projects-in-directory "~/work")
      (projectile-discover-projects-in-directory "~/proj")
    #+END_SRC

** purpose

   #+BEGIN_SRC emacs-lisp
     (setq purpose-user-mode-purposes '((magit-mode . magit)
                                        (slack-mode . slack)))
     (setq purpose-user-regexp-purposes '(
                                          ;("^*scratch: [\"a-zA-Z0-9]" . edit)
                                          ))

     (purpose-compile-user-configuration)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (add-hook 'magit-mode-setup-hook 'td/dedicate-window-purpose)
   #+END_SRC

** slack

   #+BEGIN_SRC emacs-lisp
     (setq slack-prefer-current-team t
           slack-buffer-function #'switch-to-buffer)
   #+END_SRC

*** Set up slack for =work=

  #+BEGIN_SRC emacs-lisp
    (spacemacs|use-package-add-hook slack
      :post-config
      (let* ((auth-info (car (auth-source-search :max 1
                                                 :user "work"
                                                 :host "slack")))

             (team-name (plist-get auth-info :team-name))
             (client-id (plist-get auth-info :client-id))
             (client-secret (plist-get auth-info :client-secret))
             (token (plist-get auth-info :token)))

        (slack-register-team
         :default t
         :name team-name
         :client-id client-id
         :client-secret client-secret
         :token token)))
  #+END_SRC

** tox

   #+BEGIN_SRC emacs-lisp
     (setq tox-runner 'py.test)
   #+END_SRC

** Diminish modes
   #+BEGIN_SRC emacs-lisp
     (defmacro diminish-minor-mode (filename mode &optional abbrev)
       `(eval-after-load (symbol-name ,filename)
          '(diminish ,mode ,abbrev)))

     (defmacro diminish-major-mode (mode-hook abbrev)
       `(add-hook ,mode-hook
                  (lambda () (setq mode-name ,abbrev))))

     (diminish-minor-mode 'with-editor 'with-editor-mode)
     (diminish-minor-mode 'simple 'auto-fill-function)
     (diminish-minor-mode 'server 'server-buffer-clients)

     (diminish-minor-mode 'org-indent 'org-indent-mode)
     (diminish-minor-mode 'org-src    'org-src-mode)

     (diminish-major-mode 'emacs-lisp-mode-hook "elisp")
     (diminish-major-mode 'lisp-interaction-mode-hook "λ")
     (diminish-major-mode 'python-mode-hook "Py")
   #+END_SRC
*** The End

    #+BEGIN_SRC emacs-lisp
    )
    #+END_SRC
* Key bindings
** =;= <-> =:= in every modes

   #+BEGIN_SRC emacs-lisp
     (global-set-key ":" (lambda () (interactive) (insert ";")))
     (global-set-key ";" (lambda () (interactive) (insert ":")))
   #+END_SRC

** =SPC fee= to edit configurations

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "fee" 'td/edit-configuration)
   #+END_SRC

** =SPC [0-9]=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "0" 'delete-other-windows)
     (spacemacs/set-leader-keys "7" 'async-shell-command)
     (spacemacs/set-leader-keys "9" 'zen)
   #+END_SRC

** =SPC oo= to edit =org-default-notes-file=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys "oo" '(lambda ()
                                        (interactive)
                                        (find-file org-default-notes-file)))
   #+END_SRC

** =f= and =t=

   #+BEGIN_SRC emacs-lisp
     (define-key evil-normal-state-map "f" 'evil-avy-goto-char-2)
     (define-key evil-visual-state-map "f" 'evil-avy-goto-char-in-line)

     (defun evil-avy-find-char-to-in-line ()
       "Somehow this magically makes `evil-avy-goto-char' works as `evil-find-char-to'"
       (interactive)
       (evil-avy-goto-char-in-line))

     (define-key evil-visual-state-map "t" 'evil-avy-find-char-to-in-line)
     (define-key evil-operator-state-map "t" 'evil-avy-find-char-to-in-line)
   #+END_SRC

** =SPC jj= and =SPC jk=

   #+BEGIN_SRC emacs-lisp

     (evil-define-avy-motion avy-goto-line-above line)
     (evil-define-avy-motion avy-goto-line-below line)

     (spacemacs/set-leader-keys
       "jj" 'evil-avy-goto-line-below
       "jk" 'evil-avy-goto-line-above)
   #+END_SRC
** =SPC gc= and =SPC gC=

   #+BEGIN_SRC emacs-lisp
     (spacemacs/set-leader-keys
       "gc" 'magit-commit
       "gC" 'magit-clone)
   #+END_SRC

* TODOs
** ace-jump-line-mode render marks on the same column as the cursor
** layout with purpose
*** Ref: https://emacs.stackexchange.com/questions/9995/set-windows-layout-by-a-function
*** Save a window layout (say, code + git) with purpose and copy it into emacs's config
*** Set =dedicated= to =t=
*** When switching project, load that config and open the buffers (and let purpose do its work)
** alert
*** compilation finish
*** git push finish
** SPC gc should do magit commit
   SPC gC should be magit clone

